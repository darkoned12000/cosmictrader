<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Trader</title>
    <style>
        /* --- Styles --- */
        body { font-family: monospace; background: #111; color: #0f0; margin: 0; padding: 20px; display: flex; flex-direction: column; gap: 20px; }
        #title-banner { border: 2px solid #0f0; background: #222; text-align: center; padding: 10px; }
        #title-banner pre { margin: 0; line-height: 1; color: #0f0; font-size: 10px; }
        #main-ui { display: flex; gap: 20px; flex-wrap: nowrap; align-items: flex-start; }
        #left-column, #right-column { display: flex; flex-direction: column; gap: 20px; }
        #left-column { flex: 0 0 280px; }
        #right-column { flex: 0 0 300px; }
        #center-column { flex: 1; display: flex; flex-direction: column; gap: 20px; min-width: 500px; }
        #ship-status, #game-controls, #inventory, #interaction, #galaxy-map, #space-port-actions, #info-feed { border: 1px solid #0f0; padding: 10px; background: #222; }
        h3 { margin: 0 0 10px 0; color: #0f0; border-bottom: 1px solid #0f0; padding-bottom: 5px; font-size: 14px;}
        #info-feed-content { white-space: pre-wrap; line-height: 1.3; font-size: 12px; }
        #info-feed-content strong { color: #0f0; display: inline-block; width: 120px; }
        #ship-info, #inv-info { line-height: 1.4; padding: 5px; font-size: 12px; }
        #ship-info div, #inv-info div { margin-bottom: 5px; }
        #galaxy-map { border: 1px solid #0f0; padding: 10px; /* background: url('galaxy-bg.jpg'); */ background-color: #1a1a1a; position: relative; }
        #map-container { display: flex; gap: 20px; align-items: flex-start; }
        #map-display { margin: 0; line-height: 1; white-space: pre; font-size: 12px; background: rgba(0, 0, 0, 0.6); padding: 5px; display: inline-block; color: #0f0; border: 1px dashed #050; min-width: 400px; }
        #map-legend { flex: 0 0 150px; color: #0f0; background: rgba(0, 0, 0, 0.6); padding: 5px; border: 1px dashed #050; }
        #map-legend h4 { margin: 0 0 10px 0; font-size: 14px; text-align: center; }
        #map-legend p { margin: 5px 0; font-size: 12px; }
        #space-port-actions { display: none; overflow-y: auto; max-height: 350px; }
        #interaction-display { line-height: 1; white-space: pre-wrap; margin-bottom: 10px; text-align: center; /* Center ASCII/Image */ }
        .interaction-image { max-width: 100%; max-height: 150px; display: block; margin: 0 auto 10px auto; border: 1px solid #050; }
        #interaction-controls p { margin-top: 10px; margin-bottom: 8px; } /* Add margin */
        #interaction-controls hr { border: none; border-top: 1px dashed #050; margin: 10px 0; }
        #interaction-controls div { margin-bottom: 5px; } /* Space between activity buttons */
        #interaction-controls pre { margin: 0; line-height: 1.2; } /* Style for stock info */
        #space-port-controls { display: flex; flex-direction: column; gap: 15px; }
        #space-port-controls > div { border-top: 1px dashed #030; padding-top: 10px; margin-top: 5px; } /* Add lines between sections */
        #space-port-controls > div:first-child { border-top: none; padding-top: 0; margin-top: 0; } /* No line above first */
        #space-port-actions {
        /* Existing styles */
        overflow-y: auto;
        max-height: 350px;
        /* Scrollbar styles */
        scrollbar-width: thin; /* For Firefox */
        scrollbar-color: #0f0 #111; /* For Firefox: thumb color, track color */
        }

        /* WebKit (Chrome, Safari, Edge) */
        #space-port-actions::-webkit-scrollbar {
            width: 8px; /* Match slider height */
        }

        #space-port-actions::-webkit-scrollbar-track {
            background: #111; /* Black track */
            border: 1px solid #0f0; /* Green border */
            border-radius: 5px;
        }

        #space-port-actions::-webkit-scrollbar-thumb {
            background: #0f0; /* Green thumb */
            border: 1px solid #0a0; /* Slightly darker green border */
            border-radius: 5px;
        }

        #space-port-actions::-webkit-scrollbar-thumb:hover {
            background: #0a0; /* Darker green on hover, matching slider */
        }

        /* Scrollbar arrows (if supported) */
        #space-port-actions::-webkit-scrollbar-button {
            background: #111;
            border: 1px solid #0f0;
            color: #0f0;
        }
        .button-group { display: flex; flex-wrap: wrap; gap: 5px; }
        button { background: #0f0; color: #111; border: 1px solid #0a0; padding: 8px 12px; cursor: pointer; margin: 3px; font-size: 12px; font-family: monospace; }
        button:hover { background: #0a0; border-color: #0f0; }
        button:disabled { background: #555; color: #999; border-color: #444; cursor: not-allowed; }
        button:disabled:hover { background: #555; }
        select, input[type="number"], input[type="text"] { background: #222; color: #0f0; border: 1px solid #0f0; padding: 5px; margin: 0 5px 5px 0; font-family: monospace; box-sizing: border-box; }
        select:disabled, input:disabled { background: #555; color: #999; cursor: not-allowed; border-color: #555; }
         label { margin-right: 5px; display: inline-block; margin-bottom: 5px; }
         #game-controls div { margin-bottom: 5px; }
         #game-controls hr { border: none; border-top: 1px dashed #050; margin: 10px 0; }
         #game-controls .audio-setting { display: flex; flex-wrap: wrap; align-items: center; gap: 5px; margin-bottom: 8px; }
         #game-controls .audio-setting label { flex-basis: 90px; flex-shrink: 0; text-align: right; padding-right: 5px; }
         #game-controls input[type="range"] { flex-grow: 1; min-width: 80px; height: 8px; background: #111; border: 1px solid #0f0; border-radius: 5px; cursor: pointer; vertical-align: middle; -webkit-appearance: none; appearance: none; margin:0; padding: 0;}
         #game-controls input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 16px; height: 16px; background: #0f0; border: 1px solid #0a0; border-radius: 50%; cursor: pointer; margin-top: -5px;}
         #game-controls input[type="range"]::-moz-range-thumb { width: 15px; height: 15px; background: #0f0; border: 1px solid #0a0; border-radius: 50%; cursor: pointer; }
         #game-controls input[type="range"]::-moz-range-track { width: 100%; height: 8px; background: #111; border: 1px solid #0f0; border-radius: 5px; cursor: pointer; }
         #game-controls select { flex-grow: 1; min-width: 100px; }
         #game-controls .audio-setting span { font-size: 10px; min-width: 35px; text-align: right; }
         #game-controls input[type="checkbox"] { -webkit-appearance: none; appearance: none; background-color: #111; margin: 0; font: inherit; color: #0f0; width: 1.15em; height: 1.15em; border: 0.15em solid currentcolor; border-radius: 0.15em; transform: translateY(-0.075em); display: inline-grid; place-content: center; cursor: pointer; vertical-align: middle; }
         #game-controls input[type="checkbox"]::before { content: ""; width: 0.65em; height: 0.65em; transform: scale(0); transition: 100ms transform ease-in-out; box-shadow: inset 1em 1em #0f0; clip-path: polygon(14% 44%, 0 65%, 50% 100%, 100% 16%, 80% 0%, 43% 62%); }
         #game-controls input[type="checkbox"]:checked::before { transform: scale(1); }
         #game-controls input[type="checkbox"]:focus { outline: max(2px, 0.15em) solid #0a0; outline-offset: max(2px, 0.1em); }
         #game-controls .loop-label { flex-basis: auto !important; text-align: left !important; padding-right: 10px; }
    </style>
</head>
<body>
    <audio id="bgm-audio" loop></audio>
    <audio id="sfx-audio"></audio>

    <div id="title-banner">
        <pre>  
  ______   ______        _______..___  ___.  __    ______    .___________..______          ___       _______   _______ .______      
  /      | /  __  \      /       ||   \/   | |  |  /      |   |           ||   _  \        /   \     |       \ |   ____||   _  \     
 |  ,----'|  |  |  |    |   (----`|  \  /  | |  | |  ,----'   `---|  |----`|  |_)  |      /  ^  \    |  .--.  ||  |__   |  |_)  |    
 |  |     |  |  |  |     \   \    |  |\/|  | |  | |  |            |  |     |      /      /  /_\  \   |  |  |  ||   __|  |      /     
 |  `----.|  `--'  | .----)   |   |  |  |  | |  | |  `----.       |  |     |  |\  \----./  _____  \  |  '--'  ||  |____ |  |\  \----.
  \______| \______/  |_______/    |__|  |__| |__|  \______|       |__|     | _| `._____/__/     \__\ |_______/ |_______|| _| `._____|
                                                                                                                                     
        </pre></div> 
    <div id="main-ui">
        <div id="left-column">
            <div id="ship-status"><h3>Ship Status</h3><p id="ship-info"></p></div>
            <div id="info-feed"><h3>Sector Information</h3><div id="info-feed-content">Initializing...</div></div>
            <div id="game-controls">
                <h3>Game Controls</h3>
                 <div class="audio-setting"><label for="map-size">Map Size:</label><select id="map-size" onchange="restartGame()"><option value="5000">5000</option><option value="10000">10000</option><option value="20000">20000</option></select></div>
                <hr>
                <div class="audio-setting"><label for="music-volume">Music Vol:</label><input type="range" id="music-volume" min="0" max="1" step="0.01" value="0.3"><span id="music-volume-label">30%</span></div>
                <div class="audio-setting"><label for="sfx-volume">Effects Vol:</label><input type="range" id="sfx-volume" min="0" max="1" step="0.01" value="0.5"><span id="sfx-volume-label">50%</span></div>
                <div class="audio-setting"><label for="music-theme">Music Theme:</label><select id="music-theme"></select></div>
                <div class="audio-setting"><label for="music-loop" class="loop-label">Loop Music:</label><input type="checkbox" id="music-loop" checked></div>
                <hr>
                <div><button onclick="saveGame()">Save Game</button><button onclick="loadGame()">Load Game</button></div>
            </div>
        </div>
        <div id="center-column">
            <div id="galaxy-map">
                <h3>Galaxy Map</h3>
                <div id="map-container"><pre id="map-display"></pre><div id="map-legend"><h4>Legend</h4><p>@ Player</p><p>P Port</p><p>S Space Port</p><p>O Planet/Moon</p><p>B Star</p><p>C Trader</p><p>V Vinari</p><p>D Duran</p><p>H Hazard</p><p>. Empty</p><p>&nbsp; Unscanned</p></div></div>
                <div><button onclick="triggerAction('move','up')">Up</button><button onclick="triggerAction('move','down')">Down</button><button onclick="triggerAction('move','left')">Left</button><button onclick="triggerAction('move','right')">Right</button><button onclick="triggerAction('deployMine')" id="deploy-mine-button">Deploy Mine</button></div>
            </div>
            <div id="space-port-actions"><h3 id="space-port-title">Computer</h3><div id="space-port-controls"></div></div>
        </div>
        <div id="right-column">
            <div id="inventory"><h3>Inventory</h3><p id="inv-info"></p></div>
            <div id="interaction"><h3>Interaction</h3><div id="interaction-display"></div><div id="interaction-controls"></div></div>
        </div>
    </div>

    <script>
        // --- DATA STRUCTURES ---
        // Added computerLevel to shipClasses
        const shipClasses = {'Interceptor':{price:5000,hull:100,maxHull:1000,fuel:100,maxFuel:250,cargoSpace:25,maxCargoSpace:100,shields:80,maxShields:80,mines:0,maxMines:10,fighters:50,maxFighters:100,missiles:0,maxMissiles:10,gndForces:0,maxGndForces:10,scanner:{model:'Basic',range:7},cloakEnergy:50,maxCloakEnergy:50,warpDrive:'Not Installed', computerLevel: 1},'Heavy Transport':{price:15000,hull:250,maxHull:5000,fuel:250,maxFuel:1000,cargoSpace:500,maxCargoSpace:1000,shields:250,maxShields:1000,mines:0,maxMines:20,fighters:100,maxFighters:200,missiles:1,maxMissiles:10,gndForces:0,maxGndForces:100,scanner:{model:'Standard',range:10},cloakEnergy:100,maxCloakEnergy:250,warpDrive:'Not Installed', computerLevel: 1},'Long Range Explorer':{price:50000,hull:250,maxHull:7500,fuel:250,maxFuel:2000,cargoSpace:150,maxCargoSpace:500,shields:250,maxShields:2000,mines:5,maxMines:50,fighters:100,maxFighters:250,missiles:1,maxMissiles:25,gndForces:20,maxGndForces:100,scanner:{model:'Advanced',range:15},cloakEnergy:250,maxCloakEnergy:250,warpDrive:'Not Installed', computerLevel: 2},'Battleship':{price:75000,hull:1000,maxHull:12500,fuel:500,maxFuel:3000,cargoSpace:250,maxCargoSpace:750,shields:500,maxShields:5000,mines:5,maxMines:100,fighters:250,maxFighters:500,missiles:5,maxMissiles:50,gndForces:20,maxGndForces:250,scanner:{model:'Standard',range:10},cloakEnergy:250,maxCloakEnergy:500,warpDrive:'Not Installed', computerLevel: 3},'Heavy Assault Cruiser':{price:100000,hull:2500,maxHull:25000,fuel:1000,maxFuel:10000,cargoSpace:500,maxCargoSpace:1000,shields:2500,maxShields:25000,mines:10,maxMines:150,fighters:500,maxFighters:1000,missiles:10,maxMissiles:75,gndForces:50,maxGndForces:500,scanner:{model:'Standard',range:10},cloakEnergy:250,maxCloakEnergy:1000,warpDrive:'Not Installed', computerLevel: 4},'Vanguard Destroyer':{price:150000,hull:5000,maxHull:50000,fuel:1000,maxFuel:15000,cargoSpace:750,maxCargoSpace:2000,shields:5000,maxShields:50000,mines:50,maxMines:200,fighters:1000,maxFighters:2000,missiles:20,maxMissiles:100,gndForces:100,maxGndForces:1000,scanner:{model:'Advanced',range:15},cloakEnergy:250,maxCloakEnergy:2000,warpDrive:'Not Installed', computerLevel: 5}};
        const scannerModels = { Basic: { range: 7, cost: 0 }, Standard: { range: 10, cost: 12000 }, Advanced: { range: 15, cost: 25000 } };
        const equipmentCosts = { shields: { cost: 500, amount: 100, max: 'maxShields' }, mines: { cost: 100, amount: 1, max: 'maxMines' }, fighters: { cost: 200, amount: 1, max: 'maxFighters' }, missiles: { cost: 300, amount: 1, max: 'maxMissiles' }, cargoSpace: { cost: 1000, amount: 50, max: 'maxCargoSpace' }, hull: { cost: 1000, amount: 100, max: 'maxHull' }, cloakEnergy: { cost: 500, amount: 100, max: 'maxCloakEnergy' }, gndForces: { cost: 100, amount: 10, max: 'maxGndForces' }, fuel: { cost: 50, amount: 100, unitCost: 0.5 } };
        const commodities = ['ore', 'food', 'tech'];
        const portTypes = ['SBB', 'SBS', 'SSB', 'BSS', 'BBS', 'BSB', 'SSS', 'BBB'];
        const planetNames = ["Terra", "Xylos", "Cygnus", "Kepler", "Gliese", "Arakis", "Magrathea", "Klendathu", "LV-426", "Pandora"];
        const planetTypes = ["Terran", "Jungle", "Desert", "Ocean", "Ice", "Lava", "Gas Giant", "Barren", "Toxic"];
        const planetAtmospheres = ["N2-O2", "CO2", "Methane", "Ammonia", "Acid", "Thin", "None", "Dense"];
        const planetOwnership = ["Unclaimed", "Federation", "Duran", "Vinari", "Pirate", "Colony"];
        const npcShipNames = ["Bucket", "Stardust", "Runner", "Comet", "Nomad", "Griffin", "Hammer", "Wanderer", "Zephyr", "Goliath"];
        const npcShipClasses = ["Freighter", "Scout", "Gunship", "Raider", "Patrol", "Cruiser"];
        const npcHostility = ["Low", "Med", "High", "Unknown"];
        const starNames = ["Sol", "Sirius", "Proxima", "Vega", "Rigel", "Betelgeuse", "Antares", "Arcturus", "Spica", "Polaris"];
        const starTypes = ["G-Type", "K-Type", "M-Type", "O-Type", "B-Type", "WD"];
        const portImages = ['Images/ports/Port_1.png', 'Images/ports/Port_2.png', 'Images/ports/Port_3.png', 'Images/ports/Port_4.png', 'Images/ports/Port_5.png'];
        const spacePortImages = ['Images/stations/Station_1.png', 'Images/stations/Station_2.png', 'Images/stations/Station_3.png'];
    
        // --- IMAGE DATA ---
        const planetImagesByType = {"Terran":["Images/planets/Terran_World_1.gif","Images/planets/Terran_World_2.gif"],"Jungle":["Images/planets/Jungle_World_1.gif"],"Desert":["Images/planets/Desert_World_1.gif"],"Ocean":["Images/planets/Ocean_World_1.gif"],"Ice":["Images/planets/Ice_World_1.gif"],"Lava":["Images/planets/Lava_World_1.gif"],"Gas Giant":["Images/planets/Gas_Giant_1.gif"],"Barren":["Images/planets/Moon_1.gif"],"Toxic":["Images/planets/Toxic_World_1.gif"],"Unknown":["Images/planets/Unknown_World_1.gif"]}; // Assuming Images/planets folder
        const starImagesByType = {"G-Type":["Images/stars/Star_Yellow_1.gif"],"K-Type":["Images/stars/Star_Orange_1.gif"],"M-Type":["Images/stars/Star_Red_1.gif"],"O-Type":["Images/stars/Star_Blue_1.gif"],"B-Type":["Images/stars/Star_BlueWhite_1.gif"],"WD":["Images/stars/Star_White_1.gif"],"Unknown":["Images/stars/Star_Unknown_1.gif"]}; // Assuming Images/stars folder
        const hazardImagesByType = {"Mine":["Images/hazards/Mines.png"],"Black Hole":["Images/hazards/Black_Hole_1.gif", "Images/hazards/Black_Hole_2.gif", "Images/hazards/Black_Hole_3.gif"],"Asteroid Field":["Images/hazards/Asteroid_1.gif", "Images/hazards/Asteroid_2.gif", "Images/hazards/Asteroid_3.gif"],"Solar Storm":["Images/hazards/SolarStorm.png"],"Nebula":["Images/hazards/Nebula.png"],"Unknown":["Images/hazards/unknown_1.gif"]}; // Assuming Images/hazards folder
    
        // --- HAZARD DATA ---
        const hazardTypes = ["Black Hole", "Asteroid Field", "Mine", "Solar Storm", "Nebula"];
        // Define virus types and their effects
        // Effects are functions that take the player object and modify it
        const virusTypes = [
            { name: "Credit Drain", effect: (player) => { const loss = Math.ceil(player.credits * 0.005); player.credits = Math.max(0, player.credits - loss); return `-${loss} credits`; }, duration: 20 }, // Drain 0.5% credits per move
            { name: "Shield Malfunction", effect: (player) => { const loss = 5; player.ship.shields = Math.max(0, player.ship.shields - loss); return `-${loss} shields`; }, duration: 15 }, // Lose 5 shields per move
            // { name: "Weapon Lockout", effect: (player) => { /* Placeholder - need combat system */ return "Weapons Offline (N/I)"; }, duration: 5 }, // Not implemented yet
            { name: "Fuel Leak", effect: (player) => { const loss = 1; player.ship.fuel = Math.max(0, player.ship.fuel - loss); return `-1 fuel`; }, duration: 25 }, // Lose 1 fuel per move
            // { name: "Scanner Glitch", effect: (player) => { /* Placeholder - need scanner effect */ return "Scanner Range Reduced (N/I)"; }, duration: 10 }, // Not implemented yet
            { name: "Navigation Scramble", effect: (player) => { /* Placeholder - could slightly alter course or increase fuel cost */ return "Navigation Unreliable (N/I)"; }, duration: 10}, // Not implemented yet
            { name: "System Sluggishness", effect: (player) => { /* Placeholder - could slow down menu interaction or repair rates */ return "Systems Lagging (N/I)"; }, duration: 15}, // Not implemented yet
        ];

        function engageCombat(npc) {
            const playerStrength = game.player.ship.fighters + game.player.ship.missiles * 10 + game.player.ship.shields;
            const npcStrength = npc.fighters + npc.shieldStr + npc.hullDensity * 0.5;
            const successChance = playerStrength / (playerStrength + npcStrength);
            if (Math.random() < successChance) {
                game.player.credits += getRandomInt(100, 1000);
                alert(`Victory! You defeated ${npc.name} and looted credits!`);
                game.map[`${npc.x},${npc.y}`] = null; // Remove NPC
                game.npcs = game.npcs.filter(n => n !== npc);
            } else {
                game.player.ship.shields = Math.max(0, game.player.ship.shields - 50);
                game.player.ship.hull = Math.max(0, game.player.ship.hull - 20);
                alert(`Defeat! ${npc.name} damaged your ship!`);
                if (game.player.ship.hull <= 0) {
                    alert("Ship destroyed! Game over!");
                    initGame();
                }
            }
            playSoundEffect('ship_destroyed');
            updateUI();
        }
    
    
        // --- AUDIO DATA ---
        const musicThemes = [ { name: "Darkness Below", file: "Music/The-Darkness-Below.mp3" }, { name: "Star Light", file: "Music/Star-Light.mp3" }, { name: "Solar Storm", file: "Music/Solar-Storm.mp3" }, { name: "Cold Moon", file: "Music/Cold-Moon.mp3" }]; // Assuming Music folder
        const soundEffects = { 'warp_engage': 'Effects/snd_warp_start.wav', 'mine_hit': 'Effects/snd_explosion_1.ogg', 'trade_buy': 'Effects/snd_cha_ching.mp3', 'trade_sell': 'Effects/snd_coin_drop.wav', 'ui_click': 'Effects/snd_ui_click.wav', 'ship_bought': 'Effects/snd_ship_purchase.mp3', 'upgrade': 'Effects/snd_upgrade.wav', 'error': 'Effects/snd_error.ogg', 'low_fuel': 'Effects/snd_alarm_fuel.ogg', 'ship_destroyed': 'Effects/snd_explosion_large.mp3', 'hack_success': 'Effects/snd_access_granted.wav', 'hack_fail': 'Effects/snd_access_denied.wav', 'virus_infect': 'Effects/snd_alarm_red.ogg', 'virus_clean': 'Effects/snd_heal.wav' }; // Assuming Effects folder, Added hack and virus sounds
    
        // --- GAME STATE ---
        // Added viruses array to player
        const game = { mapSize: 5000, mapWidth: 100, mapHeight: 50, viewWidth: 50, viewHeight: 20, hasMoved: false, moveCount: 0, player: { x: 1, y: 1, credits: 5000, ship: {}, inventory: { ore: 0, food: 0, tech: 0 }, class: 'Interceptor', name: "Player", viruses: [] }, map: {}, ports: [], planets: [], npcs: [], stars: [], hazards: [], audioInitialized: false, sfxVolume: 0.5 };
    
        // --- DOM REFERENCES ---
        const ui = { shipInfo: document.getElementById('ship-info'), invInfo: document.getElementById('inv-info'), infoFeedContent: document.getElementById('info-feed-content'), mapDisplay: document.getElementById('map-display'), interactionDisplay: document.getElementById('interaction-display'), interactionControls: document.getElementById('interaction-controls'), spacePortBox: document.getElementById('space-port-actions'), spacePortTitle: document.getElementById('space-port-title'), spacePortControls: document.getElementById('space-port-controls'), mapSizeSelect: document.getElementById('map-size'), deployMineButton: document.getElementById('deploy-mine-button'), musicVolumeSlider: document.getElementById('music-volume'), musicVolumeLabel: document.getElementById('music-volume-label'), sfxVolumeSlider: document.getElementById('sfx-volume'), sfxVolumeLabel: document.getElementById('sfx-volume-label'), musicThemeSelect: document.getElementById('music-theme'), musicLoopCheckbox: document.getElementById('music-loop'), bgmAudio: document.getElementById('bgm-audio'), sfxAudio: document.getElementById('sfx-audio') };
    
        // --- HELPERS ---
        function getRandomInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
        function getRandomElement(arr) { if (!arr || arr.length === 0) return null; return arr[Math.floor(Math.random() * arr.length)]; }
        function getRandomImage(imageArray) {
            if (!imageArray || imageArray.length === 0) return '';
            const idx = Math.floor(Math.random() * imageArray.length);
            const imgPath = imageArray[idx];
            // Validate image path or provide fallback
            const img = new Image();
            img.src = imgPath;
            img.onerror = () => console.warn(`Image failed to load: ${imgPath}`);
            return imgPath;
        }
    
        // --- AUDIO ---
        function initAudioControls() { ui.musicThemeSelect.innerHTML = ''; musicThemes.forEach((t) => { const o = document.createElement('option'); o.value = t.file; o.textContent = t.name; ui.musicThemeSelect.appendChild(o); }); game.sfxVolume = parseFloat(ui.sfxVolumeSlider.value); ui.bgmAudio.volume = parseFloat(ui.musicVolumeSlider.value); ui.musicVolumeLabel.textContent = `${Math.round(ui.bgmAudio.volume*100)}%`; ui.sfxVolumeLabel.textContent = `${Math.round(game.sfxVolume*100)}%`; ui.bgmAudio.loop = ui.musicLoopCheckbox.checked; if(ui.musicThemeSelect.value) ui.bgmAudio.src = ui.musicThemeSelect.value; ui.musicVolumeSlider.oninput = () => { const v = parseFloat(ui.musicVolumeSlider.value); ui.bgmAudio.volume = v; ui.musicVolumeLabel.textContent = `${Math.round(v*100)}%`; }; ui.sfxVolumeSlider.oninput = () => { game.sfxVolume = parseFloat(ui.sfxVolumeSlider.value); ui.sfxVolumeLabel.textContent = `${Math.round(game.sfxVolume*100)}%`; }; ui.musicThemeSelect.onchange = () => { if(ui.musicThemeSelect.value){ ui.bgmAudio.src = ui.musicThemeSelect.value; ui.bgmAudio.load(); if(game.audioInitialized) ui.bgmAudio.play().catch(e=>console.warn("Audio play failed:", e)); }}; ui.musicLoopCheckbox.onchange = () => { ui.bgmAudio.loop = ui.musicLoopCheckbox.checked; }; }
        function playSoundEffect(effectName) {
            if (!game.audioInitialized || !soundEffects[effectName]) return;
            try {
                ui.sfxAudio.src = soundEffects[effectName];
                ui.sfxAudio.volume = game.sfxVolume;
                ui.sfxAudio.play().catch(e => console.warn(`SFX failed: ${effectName}`, e));
            } catch (e) {
                console.warn(`SFX error for ${effectName}:`, e);
            }
        }
        function attemptFirstAudioPlay() { if (!game.audioInitialized && ui.bgmAudio.src) { console.log("Attempting BGM..."); ui.bgmAudio.play().then(() => { console.log("BGM started."); game.audioInitialized = true; }).catch(e => { console.warn("BGM failed:", e); game.audioInitialized = true; }); } }
    
        // --- SYSTEM MESSAGES ---
        function displaySystemMessage(message, sound = 'ui_click') {
            game.systemMessages.push({ text: message, timestamp: Date.now() });
            if (game.systemMessages.length > 10) game.systemMessages.shift(); // Keep max 10 messages
            updateSystemMessages();
            playSoundEffect(sound);
        }
        function updateSystemMessages() {
            ui.systemMessages.innerHTML = game.systemMessages.map(msg => `<div>${msg.text}</div>`).join('');
            ui.systemMessages.scrollTop = ui.systemMessages.scrollHeight; // Auto-scroll to bottom
        }

        // --- INITIALIZATION ---
        function initGame() { console.log("Init Game..."); const mapSize = parseInt(ui.mapSizeSelect.value); game.mapSize = mapSize; game.player.class = 'Interceptor'; game.player.ship = { ...shipClasses['Interceptor'] }; game.player.inventory = { ore: 0, food: 0, tech: 0 }; game.player.credits = 5000; game.player.viruses = []; // Initialize viruses
        if (mapSize === 5000) { game.mapWidth = 100; game.mapHeight = 50; } else if (mapSize === 10000) { game.mapWidth = 100; game.mapHeight = 100; } else if (mapSize === 20000) { game.mapWidth = 200; game.mapHeight = 100; } game.player.x = 1; game.player.y = 1; game.map = {}; game.ports = []; game.planets = []; game.npcs = []; game.stars = []; game.hazards = []; game.hasMoved = false; game.moveCount = 0; const totalSectors = game.mapWidth * game.mapHeight; const startPortCapacity = { ore: 5000, food: 5000, tech: 5000 };
        // Initialize Start Space Port with higher security and credits
        const startPortData = { x: 1, y: 1, type: 'spacePort', name: "Starbase Prime", prices: { ore: getRandomInt(50, 100), food: getRandomInt(20, 50), tech: getRandomInt(100, 300) }, capacity: startPortCapacity, stock: { ...startPortCapacity }, securityLevel: getRandomInt(5, 8), credits: getRandomInt(50000, 200000) };
        game.ports.push(startPortData); game.map[`1,1`] = { type: 'spacePort', data: startPortData }; const numSP = Math.max(0, Math.round(totalSectors * 0.0025) - 1); const numP = Math.round(totalSectors * 0.02); const numPl = Math.round(totalSectors * 0.01); const numN = Math.round(totalSectors * 0.005); const numS = Math.round(totalSectors * 0.008); const numH = Math.round(totalSectors * 0.015); const objectsToPlace = []; for (let i = 0; i < numSP; i++) objectsToPlace.push({ type: 'spacePort' }); for (let i = 0; i < numP; i++) objectsToPlace.push({ type: 'port' }); for (let i = 0; i < numPl; i++) objectsToPlace.push({ type: 'planet' }); for (let i = 0; i < numN; i++) objectsToPlace.push({ type: 'npc_ship' }); for (let i = 0; i < numS; i++) objectsToPlace.push({ type: 'star' }); for (let i = 0; i < numH; i++) objectsToPlace.push({ type: 'hazard' }); for (let i = objectsToPlace.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[objectsToPlace[i], objectsToPlace[j]] = [objectsToPlace[j], objectsToPlace[i]]; } console.log(`Placing ${objectsToPlace.length} objects...`); for (const obj of objectsToPlace) { let x, y, key; let att = 0; do { x = getRandomInt(0, game.mapWidth - 1); y = getRandomInt(0, game.mapHeight - 1); key = `${x},${y}`; att++; if (att > 100) { console.warn("Placement fail"); break; } } while (game.map[key]); if (game.map[key]) continue; let od = { x, y, type: obj.type }; switch (obj.type) { case 'port': case 'spacePort': const iSP=obj.type==='spacePort'; const pCap={ore:getRandomInt(1000,5000),food:getRandomInt(1000,5000),tech:getRandomInt(1000,5000)}; od.name=`${iSP?'Starbase':'Port'} ${x},${y}`; od.prices={ore:getRandomInt(50,100),food:getRandomInt(20,50),tech:getRandomInt(100,300)}; od.capacity=pCap; od.stock={...pCap};
        // Initialize Port security and credits based on type
        od.securityLevel = iSP ? getRandomInt(5, 8) : getRandomInt(0, 2); // Space Ports higher security (5-8), Ports lower (0-2)
        od.credits = iSP ? getRandomInt(50000, 200000) : getRandomInt(5000, 20000); // Space Ports more credits
    
        if(!iSP){const pT=getRandomElement(portTypes);od.portType=pT;od.behavior={ore:pT[0],food:pT[1],tech:pT[2]};commodities.forEach(c=>{if(od.behavior[c]==='B'){od.stock[c]=0;}}); } game.ports.push(od); break; case 'planet': od.name=getRandomElement(planetNames)+`-${getRandomInt(1,99)}`; od.planetType=getRandomElement(planetTypes); od.ownership=getRandomElement(planetOwnership); od.atmosphere=getRandomElement(planetAtmospheres); if(od.planetType==='Ice')od.temperature=getRandomInt(-150,-50); else if(od.planetType==='Lava')od.temperature=getRandomInt(500,1200); else if(od.planetType==='Terran'||od.planetType==='Jungle')od.temperature=getRandomInt(30,90); else od.temperature=getRandomInt(-100,400); od.lifeSigns=Math.random()<0.3?'Yes':'No'; od.habitationSigns=od.ownership!=='Unclaimed'||Math.random()<0.1?'Yes':'No'; game.planets.push(od); break; case 'npc_ship': od.name=getRandomElement(npcShipNames); od.shipClass=getRandomElement(npcShipClasses); od.hostileLevel=getRandomElement(npcHostility); od.shieldStr=getRandomInt(50,500); od.hullDensity=getRandomInt(100,1000); od.fighters=getRandomInt(0,50); if(od.name.includes("Vinari"))od.faction="Vinari"; else if(od.name.includes("Duran"))od.faction="Duran"; else od.faction="Civilian/Merc"; if(od.faction==='Vinari')od.type='vinari_ship'; else if(od.faction==='Duran')od.type='duran_ship'; else od.type='npc_trader'; game.npcs.push(od); break; case 'star': od.name=getRandomElement(starNames)+`-${getRandomInt(10,999)}`; od.starType=getRandomElement(starTypes); switch(od.starType){case "O-Type": case "B-Type": od.radiationLvl=getRandomInt(400,1200);od.gravityLvl=getRandomInt(30,100)/10; break; case "G-Type": od.radiationLvl=getRandomInt(50,150);od.gravityLvl=getRandomInt(8,15)/10; break; case "K-Type": od.radiationLvl=getRandomInt(20,80);od.gravityLvl=getRandomInt(5,9)/10; break; case "M-Type": od.radiationLvl=getRandomInt(5,30);od.gravityLvl=getRandomInt(1,5)/10; break; case "WD": od.radiationLvl=getRandomInt(1,25);od.gravityLvl="Extreme"; break; default: od.radiationLvl=getRandomInt(10,200);od.gravityLvl=getRandomInt(5,20)/10;} game.stars.push(od); break; case 'hazard': const specificHazardType = getRandomElement(hazardTypes); od.hazardType = specificHazardType; game.hazards.push(od); break; } game.map[key] = { type: obj.type, data: od }; } initAudioControls(); console.log("Init complete."); updateUI(); }
        function regeneratePortStock() {
            game.ports.forEach(p => {
                const r = 1000; // Stock regeneration divisor
                const b = 1; // Minimum stock increment
                if (p.type === 'spacePort') {
                    commodities.forEach(c => {
                        const a = Math.max(b, Math.round(p.capacity[c] / r));
                        p.stock[c] = Math.min(p.stock[c] + a, p.capacity[c]);
                    });
                } else {
                    commodities.forEach(c => {
                        if (p.behavior[c] === 'S') {
                            const a = Math.max(b, Math.round(p.capacity[c] / r));
                            p.stock[c] = Math.min(p.stock[c] + a, p.capacity[c]);
                        }
                    });
                }
                // Regenerate credits
                const maxCredits = p.type === 'spacePort' ? 200000 : 20000;
                if (p.credits < maxCredits) {
                    p.credits += Math.max(1, Math.round(p.credits * 0.01)); // 1% or min 1
                    p.credits = Math.min(p.credits, maxCredits); // Cap at max
                }
            });
        }
    
        // --- UI UPDATE FUNCTIONS ---
        function updateShipStatus() { 
            const s = game.player.ship; 
            const p = game.player; 
            const c = Object.values(p.inventory).reduce((a, b) => a + b, 0);
        // Display active viruses with their names
            let virusStatus = p.viruses.length > 0 ? `\nViruses: ${p.viruses.map(v => v.name).join(', ')}` : '';
            ui.shipInfo.innerHTML = `
                <div>Class: ${p.class}</div>
                <div>Hull: ${s.hull}/${s.maxHull}</div>
                <div>Fuel: ${s.fuel}/${s.maxFuel}</div>
                <div>Credits: ${p.credits}</div>
                <div>Cargo: ${c}/${s.maxCargoSpace}</div>
                <div>Shields: ${s.shields}/${s.maxShields}</div>
                <div>Mines: ${s.mines}/${s.maxMines}</div>
                <div>Fighters: ${s.fighters}/${s.maxFighters}</div>
                <div>Missiles: ${s.missiles}/${s.maxMissiles}</div>
                <div>Gnd Forces: ${s.gndForces}/${s.maxGndForces}</div>
                <div>Scanner: ${s.scanner.model} (${s.scanner.range})</div>
                <div>Cloak Energy: ${s.cloakEnergy}/${s.maxCloakEnergy}</div>
                <div>Warp Drive: ${s.warpDrive}</div>
                <div>Computer LVL: ${s.computerLevel}</div>
                ${virusStatus}
            `; // Added Computer Level and Viruses
        }
        function updateInventory() { 
            ui.invInfo.innerHTML = `
                <div>Ore: ${game.player.inventory.ore}</div>
                <div>Food: ${game.player.inventory.food}</div>
                <div>Tech: ${game.player.inventory.tech}</div>
            `; 
        }
        function updateInformationFeed() { const s = game.map[`${game.player.x},${game.player.y}`]; let h = ''; const si = "[Neutral]"; const sc = `${game.player.x},${game.player.y}`; const f = (l, v) => `<strong>${l}:</strong> ${v||'N/A'}\n`; if (s) { const d = s.data; switch (s.type) { case 'port': h += f("Name", d.name); h += f("Sector", si); h += f("Coords", sc); h += f("Type", `Port(${d.portType})`); h += f("Ore $", d.prices.ore); h += f("Food $", d.prices.food); h += f("Tech $", d.prices.tech); h += f("Fuel $", `${equipmentCosts.fuel.unitCost}/u`);
        // Display Port Credits and Security based on Player's Computer Level
        // Threshold for visibility: Player's Computer Level must be >= Port's Security Level
        if (game.player.ship.computerLevel >= d.securityLevel) {
            h += f("Port Credits", d.credits);
            h += f("Security LVL", d.securityLevel);
        } else {
            h += f("Port Credits", "Unknown");
            h += f("Security LVL", `LVL ${d.securityLevel} (Too High)`);
        }
        break; case 'spacePort': h += f("Name", d.name); h += f("Sector", si); h += f("Coords", sc); h += f("Type", "Space Port"); h += f("Ore $", "N/A"); h += f("Food $", "N/A"); h += f("Tech $", "N/A"); h += f("Fuel $", `${equipmentCosts.fuel.unitCost}/u`);
        // Space Ports are generally high security. Maybe require a slightly higher player level to see details?
        // Let's use the same rule: Player level >= Port security level
         if (game.player.ship.computerLevel >= d.securityLevel) {
             h += f("Port Credits", d.credits);
             h += f("Security LVL", d.securityLevel);
         } else {
             h += f("Port Credits", "Unknown");
             h += f("Security LVL", `LVL ${d.securityLevel} (Too High)`);
         }
    
        break; case 'planet': h += f("Name", d.name); h += f("Sector", si); h += f("Coords", sc); h += f("Type", d.planetType); h += f("Owner", d.ownership); h += f("Atmosphere", d.atmosphere); h += f("Temp", `${d.temperature}Â°F`); h += f("Life", d.lifeSigns); h += f("Habitation", d.habitationSigns); break; case 'npc_trader': case 'vinari_ship': case 'duran_ship': const st = s.type === 'npc_trader' ? 'Civ/Merc' : s.type === 'vinari_ship' ? 'Vinari' : 'Duran'; h += f("Name", d.name); h += f("Sector", si); h += f("Coords", sc); h += f("Type", `${st} Ship`); h += f("Class", d.shipClass); h += f("Hostility", d.hostileLevel); h += f("Shields", d.shieldStr); h += f("Hull", d.hullDensity); h += f("Fighters", `~${d.fighters}`); break; case 'hazard': const hazardType = d?.hazardType || 'Unknown'; h += f("Sector", si); h += f("Coords", sc); h += f("Type", `Hazard (${hazardType})`); if(hazardType === 'Asteroid Field') h += f("Density", "Variable"); if(hazardType === 'Solar Storm') h += f("Intensity", "Fluctuating"); if(hazardType === 'Black Hole') h += f("Singularity", "Detected"); if(hazardType === 'Nebula') h += f("Visibility", "Reduced"); if(hazardType === 'Mine') h += f("Status", "Armed"); h += f("Risk", "Varies"); break; case 'star': h += f("Name", d.name); h += f("Sector", si); h += f("Coords", sc); h += f("Type", d.starType); h += f("Radiation", `${d.radiationLvl} Rads`); const gd = typeof d.gravityLvl === 'number' ? `${d.gravityLvl.toFixed(1)} G` : d.gravityLvl; h += f("Gravity", gd); break; default: h += f("Sector", si); h += f("Coords", sc); h += f("Type", `Unknown(${s.type})`); break; } } else { h += f("Sector", si); h += f("Coords", sc); h += f("Type", "Empty"); h += f("Scan", "Clear"); } ui.infoFeedContent.innerHTML = h.trim(); }
        function renderMap() {
            const mapCache = new Map(); // Cache rendered sectors
            let m = '';
            const hW = Math.floor(game.viewWidth / 2);
            const hH = Math.floor(game.viewHeight / 2);
            let sX = Math.max(0, Math.min(game.player.x - hW, game.mapWidth - game.viewWidth));
            let sY = Math.max(0, Math.min(game.player.y - hH, game.mapHeight - game.viewHeight));
            const eX = sX + game.viewWidth;
            const eY = sY + game.viewHeight;
            const r = game.player.ship.scanner.range;

            for (let y = sY; y < eY; y++) {
                for (let x = sX; x < eX; x++) {
                    const key = `${x},${y}`;
                    if (mapCache.has(key)) {
                        m += mapCache.get(key);
                        continue;
                    }
                    let symbol = '.';
                    if (x === game.player.x && y === game.player.y) {
                        symbol = '@';
                    } else {
                        const d = Math.abs(x - game.player.x) + Math.abs(y - game.player.y);
                        if (d <= r) {
                            const s = game.map[key];
                            if (s) {
                                switch (s.type) {
                                    case 'port': symbol = 'P'; break;
                                    case 'spacePort': symbol = 'S'; break;
                                    case 'planet': symbol = 'O'; break;
                                    case 'star': symbol = 'B'; break;
                                    case 'npc_trader': symbol = 'C'; break;
                                    case 'vinari_ship': symbol = 'V'; break;
                                    case 'duran_ship': symbol = 'D'; break;
                                    case 'hazard': symbol = 'H'; break;
                                    default: symbol = '?'; break;
                                }
                            }
                        } else {
                            symbol = ' ';
                        }
                    }
                    mapCache.set(key, symbol);
                    m += symbol;
                }
                m += '\n';
            }
            ui.mapDisplay.textContent = m;
        }
        function updateInteraction() {
            const s = game.map[`${game.player.x},${game.player.y}`]; // Use 's' alias
            // --- Keep ui element references ---
            const interactionDisplay = ui.interactionDisplay;
            const interactionControls = ui.interactionControls;
            const spacePortBox = ui.spacePortBox;
            const spacePortTitle = ui.spacePortTitle;
            const spacePortControls = ui.spacePortControls;
    
            let d = ''; let i = ''; let spC = ''; let spT = 'Computer'; let sSP = true; // Use aliases
    
            if (s) {
                const dat = s.data; // Use 'dat' alias
                switch (s.type) { // Switch on general type
                    // ***** UPDATED PORT CASE *****
                    case 'port':
                        { // Use block scope
                            spT = `Port: ${dat.name || 'Trading Port'}`;
                            d = `<img src="${getRandomImage(portImages)}" alt="Port" class="interaction-image">`; // Interaction display (image)
    
                            // --- Generate Stock Info ---
                            let stockInfoHTML = '<pre style="text-align: left; margin-top: 15px; margin-bottom: 10px;"><u>Stock Status</u>\n'; // Added margin-top/bottom
                            stockInfoHTML += `Comm. | Mode    | Stock / Capacity\n`;
                            stockInfoHTML += `------|---------|-----------------\n`;
                            commodities.forEach(comm => {
                                const mode = dat.behavior[comm] === 'S' ? 'Selling' : 'Buying '; // Pad 'Buying' for alignment
                                const stockStr = String(dat.stock[comm]).padStart(5); // Pad stock to 5 chars
                                const capacityStr = String(dat.capacity[comm]).padStart(5); // Pad capacity to 5 chars
                                const commName = (comm.charAt(0).toUpperCase() + comm.slice(1)).padEnd(5); // Pad commodity name to 5 chars
                                // Adjust padding and spacing here
                                stockInfoHTML += `${commName} | ${mode} | ${stockStr} / ${capacityStr}\n`;
                            });
                            stockInfoHTML += '</pre>';
                            // --- End Stock Info ---
    
                            // Interaction Controls (Right Panel): Stock Info + Activities (buttons on own lines)
                            i = stockInfoHTML; // Start with stock info
                            i += `<hr style="border-color: #050;">`;
                            i += `<p>Port Activities:</p>`;
                            // Wrap each button in a div for block display
                            i += `<div><button onclick="triggerAction('attemptStealResources')">Steal Resources</button></div>`;
                            i += `<div><button onclick="triggerAction('attemptHackPort')">Hack Credits</button></div>`; // Added hack button
                            i += `<div><button onclick="triggerAction('playLottery')">Play Lottery(10cr)</button></div>`;
                            i += `<div><button onclick="triggerAction('attemptPurchasePort')">Inquire Purchase</button></div>`;
                            i += `<div><button onclick="triggerAction('payForTip')">Pay Tip(25cr)</button></div>`;
    
    
                            // Space Port Controls (Center Bottom Panel): Trade, Refuel, Upgrade, Security Upgrade (Warp removed)
                            spC = `
                                <div><p>Commodity Trade:</p>
                                    <div class="button-group">
                                        <button onclick="triggerAction('trade','buy','ore')" ${dat.stock.ore<=0||dat.behavior.ore==='B'?'disabled':''}>Buy Ore(${dat.prices.ore})</button>
                                        <button onclick="triggerAction('trade','buy','food')" ${dat.stock.food<=0||dat.behavior.food==='B'?'disabled':''}>Buy Food(${dat.prices.food})</button>
                                        <button onclick="triggerAction('trade','buy','tech')" ${dat.stock.tech<=0||dat.behavior.tech==='B'?'disabled':''}>Buy Tech(${dat.prices.tech})</button>
                                    </div>
                                    <div class="button-group">
                                        <button onclick="triggerAction('trade','sell','ore')" ${game.player.inventory.ore<=0||dat.behavior.ore==='S'||dat.stock.ore>=dat.capacity.ore?'disabled':''}>Sell Ore(${dat.prices.ore})</button>
                                        <button onclick="triggerAction('trade','sell','food')" ${game.player.inventory.food<=0||dat.behavior.food==='S'||dat.stock.food>=dat.capacity.food?'disabled':''}>Sell Food(${dat.prices.food})</button>
                                        <button onclick="triggerAction('trade','sell','tech')" ${game.player.inventory.tech<=0||dat.behavior.tech==='S'||dat.stock.tech>=dat.capacity.tech?'disabled':''}>Sell Tech(${dat.prices.tech})</button>
                                    </div>
                                </div>
                                <div><p>Refuel:</p>
                                    <button onclick="triggerAction('buyFuel')" ${game.player.credits<equipmentCosts.fuel.unitCost||game.player.ship.fuel>=game.player.ship.maxFuel?'disabled':''}>Buy Fuel(${equipmentCosts.fuel.unitCost}/u)</button>
                                    <label>Amt:</label><input type="number" id="buy-fuel-amount" min="1" value="100" style="width:60px;">
                                </div>
                                 <div><p>Upgrade Port:</p>
                                    <div><label>O:</label><input type="number" id="upgrade-ore" min="0" value="0" style="width:60px;"><label>F:</label><input type="number" id="upgrade-food" min="0" value="0" style="width:60px;"><label>T:</label><input type="number" id="upgrade-tech" min="0" value="0" style="width:60px;"><button onclick="triggerAction('upgradePort')">Upgrade</button></div>
                                </div>
                                <div><p>Upgrade Security:</p>
                                    <div><label>Target LVL:</label><input type="number" id="upgrade-security-level" min="${dat.securityLevel + 1}" max="10" value="${dat.securityLevel + 1}" style="width:60px;"><button onclick="triggerAction('upgradePortSecurity')">Upgrade Security</button></div>
                                </div>
                            `; // Warp controls removed from here for regular ports
                        }
                        break;
                     // ***** END UPDATED PORT CASE *****
    
                    // ***** UPDATED SPACE PORT CASE *****
                    case 'spacePort':
                         { // Use block scope
                            spT = `Space Port: ${dat.name}`; d = `<img src="${getRandomImage(spacePortImages)}" alt="Space Port" class="interaction-image">`; i = `<p>Access computer.</p>`;
                            spC = generateSpaceportServicesHTML() + generateSoftwareUpgradeHTML() + generateVirusRemovalHTML() + generateWarpControlsHTML(); // Added Software and Virus Removal
                         }
                         break;
                     // ***** END UPDATED SPACE PORT CASE *****
    
                    // Other cases remain unchanged
                    case 'planet': { spT = `Planet: ${dat.name}`; const pType=dat.planetType||"?"; const pImg=getRandomImage(planetImagesByType[pType]||planetImagesByType["Unknown"]); d=pImg?`<img src="${pImg}" alt="${pType}" class="interaction-image">\nApproaching ${pType}.`:`\n  #\n ###\n#####\n ###\n  #\nApproaching ${pType}.`; i=`<p>Access computer.</p>`; spC=`<div><p>Planet Actions(N/I):</p></div><div><button disabled>Land</button></div><div><button disabled>Scan</button></div> ${generateWarpControlsHTML()}`; break; }
                    case 'npc_trader': case 'vinari_ship': case 'duran_ship': spT = `Ship: ${dat.name}`; d = `\n   __|__\n--=<=*=>=--\n    \\ / \nDetected ${dat.shipClass||'?'} ship.`; i = `<p>Access computer.</p>`; spC = `<div><p>Combat/Comms(N/I):</p></div><div><button disabled>Hail</button></div><div><button disabled>Scan</button></div><div><button disabled>Attack</button></div> ${generateWarpControlsHTML()}`; break;
                    case 'hazard': { const hazardType = dat?.hazardType || 'Unknown'; spT = `Hazard: ${hazardType}`; const hImg = getRandomImage(hazardImagesByType[hazardType] || hazardImagesByType["Unknown"]); let hMsg="Hazard detected!"; if(hazardType === 'Mine') hMsg="Armed Mine! Damage on entry."; else if(hazardType === 'Asteroid Field') hMsg="Asteroids! Collision risk!"; else if(hazardType === 'Black Hole') hMsg="GRAVITY WELL!"; else if(hazardType === 'Solar Storm') hMsg="Solar storm! Systems affected."; else if(hazardType === 'Nebula') hMsg="Nebula. Sensors impaired."; d=hImg?`<img src="${hImg}" alt="${hazardType}" class="interaction-image">\n${hMsg}`:`\n * * DANGER * * \n * ${hazardType} * \n * * DETECTED * * \n\n${hMsg}`; i=`<p>Nav hazard present.</p>`; spC=generateWarpControlsHTML(); break; }
                    case 'star': { spT = `Star: ${dat.name}`; const sType=dat.starType||"?"; const sImg=getRandomImage(starImagesByType[sType]||starImagesByType["Unknown"]); d=sImg?`<img src="${sImg}" alt="${sType}" class="interaction-image">\nApproaching ${sType}.`:`\n   \\ | /\n -- (O) --\n   / | \\\nApproaching ${sType}.`; i=`<p>Extreme conditions.</p>`; spC=generateWarpControlsHTML(); break; }
                    default: spT = 'Computer'; d = `???\n???\n???`; i = `<p>Unknown object.</p>`; spC = generateWarpControlsHTML(); break;
                }
            } else { // Empty Sector
                 spT = 'Computer'; d = `\n   ~*~\n    . .\n   ~*~\nEmpty Space.`; i = `<p>No objects.</p>`; spC = generateWarpControlsHTML();
            }
            // Update the DOM
            ui.interactionDisplay.innerHTML = d;
            ui.interactionControls.innerHTML = i;
            ui.spacePortTitle.textContent = spT;
            ui.spacePortControls.innerHTML = spC;
            ui.spacePortBox.style.display = sSP ? 'block' : 'none';
        }
        // --- Remaining functions ---
        function generateSpaceportServicesHTML() { let h='';h+=`<div><p>Refuel:</p><button onclick="triggerAction('buyFuel')" ${game.player.credits<equipmentCosts.fuel.unitCost||game.player.ship.fuel>=game.player.ship.maxFuel?'disabled':''}>Fuel(${equipmentCosts.fuel.unitCost}/u)</button><label>Amt:</label><input type="number" id="buy-fuel-amount" min="1" value="100" style="width:60px;"></div>`;h+=`<div><p>Equip:</p><div class="button-group">`;for(const t in equipmentCosts){if(t==='fuel')continue;const i=equipmentCosts[t];const c=game.player.ship[t]||0;const m=game.player.ship[i.max]!==undefined?game.player.ship[i.max]:Infinity;const d=game.player.credits<i.cost||c>=m;const l=t[0].toUpperCase()+t.slice(1).replace('Space',' ');h+=`<button onclick="triggerAction('buyEquipment','${t}')" ${d?'disabled':''}>${l}(+${i.amount},${i.cost}cr)</button>`;}h+=`</div></div>`;if(game.player.ship.scanner.model!=='Advanced'){const n=game.player.ship.scanner.model==='Basic'?'Standard':'Advanced';const c=scannerModels[n].cost;const d=game.player.credits<c;h+=`<div><p>Scanner:</p><button onclick="triggerAction('upgradeScanner','${n}')" ${d?'disabled':''}>Buy ${n}(${c}cr)</button></div>`;}const wc=5000;const cbw=game.player.credits>=wc&&game.player.ship.warpDrive!=='Installed';h+=`<div><p>Warp:</p><button onclick="triggerAction('buyWarpDrive')" ${!cbw?'disabled':''}>Install(${wc}cr)</button></div>`;h+=`<div><p>Ships(Trade:50%):</p><div class="button-group">`;for(const sc in shipClasses){if(sc!==game.player.class){const ns=shipClasses[sc];const{netCost}=calculateTradeIn(sc);const ca=game.player.credits>=netCost;h+=`<button onclick="triggerAction('buyShip','${sc}')" ${ca?'':'disabled'}>Buy ${sc}(Net:${netCost}cr)</button>`;}}h+=`</div></div>`;return h;}
        // Generates HTML for the Player Software Upgrade section
        function generateSoftwareUpgradeHTML() {
             const currentLevel = game.player.ship.computerLevel || 1;
             const maxLevel = 10;
             if (currentLevel >= maxLevel) return ''; // Hide if max level
             const cost = currentLevel * 7500 + 5000; // Example cost calculation (e.g., Lvl 2 costs 12.5k, Lvl 3 costs 20k)
             const disabled = game.player.credits < cost;
             return `<div><p>Software Upgrades:</p><button onclick="triggerAction('upgradeSoftware')" ${disabled?'disabled':''}>Upgrade Computer LVL ${currentLevel + 1} (${cost}cr)</button></div>`;
         }
    
        // Generates HTML for the Virus Removal section
         function generateVirusRemovalHTML() {
            if (game.player.viruses.length === 0) return ''; // Hide if no viruses
            const costPerVirus = 750; // Example cost
            const totalCost = game.player.viruses.length * costPerVirus;
            const disabled = game.player.credits < totalCost;
             return `<div><p>System Diagnostics:</p><button onclick="triggerAction('removeViruses')" ${disabled?'disabled':''}>Remove Viruses (${totalCost}cr)</button></div>`;
         }
    
    
        function generateWarpControlsHTML() { if (game.player.ship.warpDrive === 'Installed') { return `<div><p>Warp(2f/s):</p><div><label>X:</label><input type="number" id="warp-x" min="0" max="${game.mapWidth-1}" value="${game.player.x}" style="width:60px;"><label>Y:</label><input type="number" id="warp-y" min="0" max="${game.mapHeight-1}" value="${game.player.y}" style="width:60px;"><button onclick="triggerAction('warpToSector')">Warp</button></div></div>`; } return '<div><p>Warp Drive: N/I</p></div>'; } // Keep N/I msg for non-port contexts
        function updateUI() { updateShipStatus(); updateInventory(); renderMap(); updateInformationFeed(); updateInteraction(); ui.deployMineButton.disabled = game.player.ship.mines <= 0; ui.mapSizeSelect.disabled = game.hasMoved; }
        function triggerAction(action, ...args) { attemptFirstAudioPlay(); playSoundEffect('ui_click'); switch (action) { case 'move': move(...args); break; case 'deployMine': deployMine(...args); break; case 'warpToSector': warpToSector(...args); break; case 'buyFuel': buyFuel(...args); break; case 'buyEquipment': buyEquipment(...args); break; case 'upgradeScanner': upgradeScanner(...args); break; case 'buyWarpDrive': buyWarpDrive(...args); break; case 'buyShip': buyShip(...args); break; case 'trade': trade(...args); break; case 'upgradePort': upgradePort(...args); break;
        case 'upgradePortSecurity': upgradePortSecurity(...args); break; // Added security upgrade
        case 'upgradeSoftware': upgradeSoftware(...args); break; // Added software upgrade
        case 'removeViruses': removeViruses(...args); break; // Added virus removal
        case 'attemptStealResources': attemptStealResources(...args); break;
        case 'attemptHackPort': attemptHackPort(...args); break; // Added hack action
        case 'playLottery': playLottery(...args); break; case 'attemptPurchasePort': attemptPurchasePort(...args); break; case 'payForTip': payForTip(...args); break; } }
        // Function to apply virus effects and decrement duration
        function applyVirusEffects() {
             game.player.viruses = game.player.viruses.filter(virus => {
                 const virusDefinition = virusTypes.find(vt => vt.name === virus.name);
                 if (virusDefinition && virusDefinition.effect) {
                     // Apply the effect
                     const effectMessage = virusDefinition.effect(game.player);
                     console.log(`Virus "${virus.name}" applied effect: ${effectMessage}`); // Optional logging
                 }
                 virus.duration--;
                 // Keep the virus if its duration is greater than 0
                 return virus.duration > 0;
             });
             // After effects, re-render relevant UI elements if needed (updateUI() does this)
        }
    
        function move(direction) {
             let nX=game.player.x; let nY=game.player.y; const fc=1;
    
             if(direction==='up'&&nY>0)nY--; else if(direction==='down'&&nY<game.mapHeight-1)nY++; else if(direction==='left'&&nX>0)nX--; else if(direction==='right'&&nX<game.mapWidth-1)nX++; else return; if(nX===game.player.x&&nY===game.player.y)return; if(game.player.ship.fuel>=fc){game.player.ship.fuel-=fc;game.player.x=nX;game.player.y=nY;game.hasMoved=true;game.moveCount++;
             applyVirusEffects(); // Apply virus effects after moving
             const s=game.map[`${nX},${nY}`];if(s&&s.type==='hazard'){handleHazardEntry(s);}if(game.moveCount%5===0){regeneratePortStock();}updateUI();if(game.player.ship.fuel<20){playSoundEffect('low_fuel');}}else{alert('Out of fuel!');playSoundEffect('error');}}
        function warpToSector() { if(game.player.ship.warpDrive!=='Installed')return; const tX=parseInt(document.getElementById('warp-x').value); const tY=parseInt(document.getElementById('warp-y').value); const wF=2; if(isNaN(tX)||isNaN(tY)||tX<0||tX>=game.mapWidth||tY<0||tY>=game.mapHeight){alert('Invalid coords!');playSoundEffect('error');return;}if(tX===game.player.x&&tY===game.player.y){alert("Cannot warp here.");playSoundEffect('error');return;}const d=Math.abs(tX-game.player.x)+Math.abs(tY-game.player.y);const fc=d*wF;if(game.player.ship.fuel<fc){alert(`Need ${fc} fuel.`);playSoundEffect('error');return;}if(confirm(`Warp to (${tX},${tY})?\nDist:${d} Cost:${fc} fuel`)){playSoundEffect('warp_engage');game.player.ship.fuel-=fc;game.player.x=tX;game.player.y=tY;game.hasMoved=true;game.moveCount+=d;
        // Apply virus effects for each sector warped over
        for(let i = 0; i < d; i++) {
             applyVirusEffects();
        }

        function moveNPCs() {
        game.npcs.forEach(npc => {
            if (Math.random() < 0.5) {
                const directions = ['up', 'down', 'left', 'right'];
                const dir = getRandomElement(directions);
                let newX = npc.x, newY = npc.y;
                if (dir === 'up' && newY > 0) newY--;
                else if (dir === 'down' && newY < game.mapHeight - 1) newY++;
                else if (dir === 'left' && newX > 0) newX--;
                else if (dir === 'right' && newX < game.mapWidth - 1) newX++;
                const newKey = `${newX},${newY}`;
                if (!game.map[newKey]) {
                    delete game.map[`${npc.x},${npc.y}`];
                    npc.x = newX; npc.y = newY;
                    game.map[newKey] = { type: npc.type, data: npc };
                }
            }
        });
    }
    
        const s=game.map[`${tX},${tY}`];if(s&&s.type==='hazard'){handleHazardEntry(s);}alert(`Warp success!`);updateUI();if(game.player.ship.fuel<20){playSoundEffect('low_fuel');}}else{alert("Warp disengaged.");}}
        function handleHazardEntry(sector) { if(!sector||sector.type!=='hazard'||!sector.data)return; const hazardType=sector.data.hazardType; let message=`Entered Hazard: ${hazardType}!`; let sound='error'; switch(hazardType){case 'Mine':sound='mine_hit';const sd=20;const hd=10;message='Hit an armed mine!';if(game.player.ship.shields>0){const asd=Math.min(game.player.ship.shields,sd);game.player.ship.shields-=asd;message+=` Shields -${asd}.`;if(asd<sd&&game.player.ship.shields===0){const hdt=hd;game.player.ship.hull=Math.max(0,game.player.ship.hull-hdt);message+=` Hull -${hdt}.`;}}else{game.player.ship.hull=Math.max(0,game.player.ship.hull-hd);message+=` Hull -${hd}.`;}break;case 'Asteroid Field':message="Navigating dense asteroid field! Minor impacts detected.";game.player.ship.shields=Math.max(0,game.player.ship.shields-getRandomInt(0,5));break;case 'Black Hole':message="WARNING: Extreme gravity ripping at the hull!";game.player.ship.hull=Math.max(0,game.player.ship.hull-getRandomInt(40,80));game.player.ship.shields=0;message+=" Hull integrity failing!";break;case 'Solar Storm':message="Caught in a solar storm! Shields overloaded.";game.player.ship.shields=Math.max(0,game.player.ship.shields-getRandomInt(25,60));message+=" Shields significantly weakened!";break;case 'Nebula':message="Entering nebula. Sensor efficiency reduced.";break;default:message="Entered unknown hazardous region! Taking minor damage.";game.player.ship.shields=Math.max(0,game.player.ship.shields-5);game.player.ship.hull=Math.max(0,game.player.ship.hull-2);break;}playSoundEffect(sound);alert(message);if(game.player.ship.hull<=0){playSoundEffect('ship_destroyed');alert("CRITICAL HULL FAILURE! SHIP DESTROYED! GAME OVER!");initGame();}updateUI();}
        function deployMine() { if(game.player.ship.mines>0){const k=`${game.player.x},${game.player.y}`;if(!game.map[k]){game.player.ship.mines--;game.map[k]={type:'hazard',data:{hazardType:'Mine',owner:game.player.name,x:game.player.x,y:game.player.y}};alert('Mine deployed.');updateUI();}else{alert('Cannot deploy mine in occupied sector!');playSoundEffect('error');}}else{alert('No mines available!');playSoundEffect('error');}}
        function buyFuel() {
            const input = document.getElementById('buy-fuel-amount')?.value;
            const a = parseInt(input, 10);
            if (isNaN(a) || a <= 0) {
                alert("Enter a positive number.");
                playSoundEffect('error');
                return;
            }
            const cpu = equipmentCosts.fuel.unitCost;
            const mca = game.player.ship.maxFuel - game.player.ship.fuel;
            const ata = Math.min(a, mca);
            const ac = Math.ceil(ata * cpu);
            if (ata <= 0) {
                alert("Tank full!");
                playSoundEffect('error');
                return;
            }
            if (game.player.credits < ac) {
                alert(`Need ${ac} cr.`);
                playSoundEffect('error');
                return;
            }
            game.player.credits -= ac;
            game.player.ship.fuel += ata;
            alert(`Bought ${ata} fuel for ${ac} cr.`);
            updateUI();
        }
        function buyEquipment(type) { const i=equipmentCosts[type];if(!i)return;const c=game.player.ship[type]||0;const m=game.player.ship[i.max]!==undefined?game.player.ship[i.max]:Infinity;if(c>=m){alert(`${type} max!`);playSoundEffect('error');return;}if(game.player.credits<i.cost){alert(`Need ${i.cost} cr.`);playSoundEffect('error');return;}game.player.credits-=i.cost;if(game.player.ship[type]===undefined)game.player.ship[type]=0;game.player.ship[type]+=i.amount;game.player.ship[type]=Math.min(game.player.ship[type],m);alert(`Bought +${i.amount} ${type}!`);playSoundEffect('upgrade');updateUI();}
        function upgradeScanner(model) { const cost=scannerModels[model].cost;if(game.player.credits>=cost){game.player.credits-=cost;game.player.ship.scanner={model,range:scannerModels[model].range};alert(`Upgraded to ${model} Scanner!`);playSoundEffect('upgrade');updateUI();}else{alert('Not enough credits!');playSoundEffect('error');}}
        function buyWarpDrive() { const cost=5000;if(game.player.ship.warpDrive==='Installed'){alert("Already installed!");playSoundEffect('error');return;}if(game.player.credits>=cost){if(confirm(`Install Warp Drive for ${cost}cr?`)){game.player.credits-=cost;game.player.ship.warpDrive='Installed';alert('Warp Drive installed!');playSoundEffect('upgrade');updateUI();}}else{alert(`Need ${cost} cr.`);playSoundEffect('error');}}
        function calculateTradeIn(newClass) { const ns=shipClasses[newClass];const old=shipClasses[game.player.class];const ov=(old.price||0)*0.5;let ev=0;for(const t in equipmentCosts){if(t==='fuel')continue;const i=equipmentCosts[t];const bv=old[t]!==undefined?old[t]:0;const cv=game.player.ship[t]!==undefined?game.player.ship[t]:0;const aa=Math.max(0,cv-bv);if(aa>0&&i.amount>0){ev+=(aa/i.amount)*i.cost*0.5;}}const cs=game.player.ship.scanner.model;const bs=old.scanner.model;if(scannerModels[cs].cost>scannerModels[bs].cost){ev+=(scannerModels[cs].cost-scannerModels[bs].cost)*0.5;}if(game.player.ship.warpDrive==='Installed'&&old.warpDrive!=='Installed'){ev+=5000*0.5;}
            // Add value for computer level
            // Assume each level adds some value to the trade-in
            const oldComputerLevel = old.computerLevel || 1;
            const currentComputerLevel = game.player.ship.computerLevel || 1;
            if (currentComputerLevel > oldComputerLevel) {
                 const levelDiff = currentComputerLevel - oldComputerLevel;
                 ev += levelDiff * 3000; // Example value per computer level
            }
    
        const tti=Math.floor(ov+ev);const net=ns.price-tti;return{totalTradeIn:tti,netCost:net};}
        function buyShip(newClass) { const ns=shipClasses[newClass];const{totalTradeIn,netCost}=calculateTradeIn(newClass);if(game.player.credits<netCost){alert(`Need ${netCost} cr.`);playSoundEffect('error');return;}const cc=Object.values(game.player.inventory).reduce((a,b)=>a+b,0);if(cc>ns.maxCargoSpace){if(!confirm(`Warning:Buying ${newClass} jettisons excess cargo! Continue?`)){return;}}if(confirm(`Trade ${game.player.class} for ${newClass}?\nNet Cost:${netCost} cr\nConfirm?`)){game.player.credits-=netCost;game.player.class=newClass;
            // Copy ship properties, but keep current computer level if higher
            const currentComputerLevel = game.player.ship.computerLevel || 1;
            game.player.ship={...ns};
            game.player.ship.computerLevel = Math.max(ns.computerLevel || 1, currentComputerLevel); // Keep the higher computer level
    
            if(cc>ns.maxCargoSpace){game.player.inventory={ore:0,food:0,tech:0};alert(`Bought ${newClass}! Cargo jettisoned.`);}else{alert(`Bought ${newClass}!`);}playSoundEffect('ship_bought');updateUI();}}
        function trade(action, commodity) { const s=game.map[`${game.player.x},${game.player.y}`];if(!s||s.type!=='port'){alert("Trade at ports only.");playSoundEffect('error');return;}const p=s.data;const pr=p.prices[commodity];const cu=Object.values(game.player.inventory).reduce((a,b)=>a+b,0);const pc=game.player.inventory;const sc=game.player.ship.maxCargoSpace;const pb=p.behavior[commodity];let snd=null;if(action==='buy'){if(pb==='B'){alert(`Port Buys ${commodity}.`);playSoundEffect('error');return;}if(p.stock[commodity]<=0){alert(`Port out of ${commodity}!`);playSoundEffect('error');return;}if(cu>=sc){alert('Cargo full!');playSoundEffect('error');return;}if(game.player.credits<pr){alert(`Need ${pr} cr.`);playSoundEffect('error');return;}game.player.credits-=pr;pc[commodity]++;p.stock[commodity]--;p.prices[commodity]=Math.min(p.prices[commodity]+1,500);alert(`Bought 1 ${commodity}.`);snd='trade_buy';}else if(action==='sell'){if(pb==='S'){alert(`Port Sells ${commodity}.`);playSoundEffect('error');return;}if(pc[commodity]<=0){alert(`No ${commodity}!`);playSoundEffect('error');return;}if(p.stock[commodity]>=p.capacity[commodity]){alert(`Port capacity full.`);playSoundEffect('error');return;}game.player.credits+=pr;pc[commodity]--;p.stock[commodity]++;p.prices[commodity]=Math.max(p.prices[commodity]-1,5);alert(`Sold 1 ${commodity}.`);snd='trade_sell';}if(snd)playSoundEffect(snd);updateUI();}
        function upgradePort() { const s=game.map[`${game.player.x},${game.player.y}`];if(!s||s.type!=='port'){alert("Upgrade ports only.");playSoundEffect('error');return;}const p=s.data;const upu=1;const mau=10000;const mcp=1000000;const oi=parseInt(document.getElementById('upgrade-ore').value)||0;const fi=parseInt(document.getElementById('upgrade-food').value)||0;const ti=parseInt(document.getElementById('upgrade-tech').value)||0;if(oi<0||fi<0||ti<0){alert("Amounts >= 0.");playSoundEffect('error');return;}const toti=oi+fi+ti;if(toti<=0){alert('Enter > 0 amount!');playSoundEffect('error');return;}if(toti>mau){alert(`Max upgrade:${mau}.`);playSoundEffect('error');return;}if(p.capacity.ore+oi>mcp||p.capacity.food+fi>mcp||p.capacity.tech+ti>mcp){alert(`Max cap/comm:${mcp}.`);playSoundEffect('error');return;}const tc=toti*upu;if(game.player.credits<tc){alert(`Need ${tc} cr.`);playSoundEffect('error');return;}game.player.credits-=tc;p.capacity.ore+=oi;p.capacity.food+=fi;p.capacity.tech+=ti;if(p.behavior.ore==='S')p.stock.ore+=oi;if(p.behavior.food==='S')p.stock.food+=fi;if(p.behavior.tech==='S')p.stock.tech+=ti;p.stock.ore=Math.min(p.stock.ore,p.capacity.ore);p.stock.food=Math.min(p.stock.food,p.capacity.food);p.stock.tech=Math.min(p.stock.tech,p.capacity.tech);alert(`Port upgraded! Cost:${tc} cr.`);playSoundEffect('upgrade');updateUI();}
    
        // --- NEW PORT ACTIVITY FUNCTIONS ---
        function attemptStealResources() { const sector = game.map[`${game.player.x},${game.player.y}`]; if (!sector || sector.type !== 'port') return; const portData = sector.data; alert("Attempting to divert cargo...");
        // Steal chance influenced by security level, but less so than hacking
        const baseChance = 0.4; // Higher base chance than hacking
        const securityPenalty = (portData.securityLevel || 0) * 0.04; // Less penalty per security level (4% per level)
        const finalChance = Math.max(0.05, baseChance - securityPenalty); // Minimum 5% chance
    
        if (Math.random() < finalChance) {
            const stolenCommodity = getRandomElement(commodities);
            // Steal amount could be influenced by player level vs port security
            const stolenAmount = getRandomInt(1, 5);
            const cargoUsed = Object.values(game.player.inventory).reduce((a, b) => a + b, 0);
            if (portData.stock[stolenCommodity] >= stolenAmount && (cargoUsed + stolenAmount) <= game.player.ship.maxCargoSpace) {
                portData.stock[stolenCommodity] -= stolenAmount;
                game.player.inventory[stolenCommodity] += stolenAmount;
                alert(`Success! Pilfered ${stolenAmount} ${stolenCommodity}!`);
                playSoundEffect('trade_buy'); // Use a success sound
            } else {
                alert("Success... but nothing to take or no space!");
                 // Still a failure for the player, maybe minor consequence?
                 playSoundEffect('error');
            }
        } else {
            // --- Failed Steal Penalty ---
            const fineAmount = getRandomInt(50, 200); // Example fine amount
            game.player.credits = Math.max(0, game.player.credits - fineAmount); // Deduct fine
            alert(`Failed! Security patrol! You were fined ${fineAmount} credits.`);
            playSoundEffect('error'); // Use a failure sound
        }
        updateUI(); }
    
        // Function to handle hacking attempts
        function attemptHackPort() {
            const sector = game.map[`${game.player.x},${game.player.y}`];
            if (!sector || (sector.type !== 'port' && sector.type !== 'spacePort')) {
                alert("Hack ports or space ports only.");
                playSoundEffect('error');
                return;
            }
            const portData = sector.data;
            const playerComputerLevel = game.player.ship.computerLevel || 1;
            const portSecurityLevel = portData.securityLevel || 0;

            // Calculate hacking success chance (between 5% and 95%)
            let baseSuccessChance = 0.4; // Start with 40% base chance
            const securityPenalty = portSecurityLevel * 0.07; // Each security level reduces chance by 7%
            const softwareBonus = (playerComputerLevel - 1) * 0.07; // Each level *above 1* increases chance by 7%

            let finalHackChance = baseSuccessChance - securityPenalty + softwareBonus;
            finalHackChance = Math.max(0.05, Math.min(0.95, finalHackChance)); // Clamp between 5% and 95%

            alert(`Attempting system hack...\nChance: ${Math.round(finalHackChance * 100)}%`);

            if (Math.random() < finalHackChance) {
                // Hack Success
                const maxStealable = Math.floor(portData.credits * 0.1); // Steal up to 10% of port's credits
                const minSteal = 100; // Minimum stolen amount
                // Ensure we don't try to steal more than the port has
                const actualMaxSteal = Math.min(maxStealable, portData.credits);
                const stolenCredits = getRandomInt(minSteal, actualMaxSteal > minSteal ? actualMaxSteal : minSteal + 100);

                game.player.credits += stolenCredits;
                portData.credits -= stolenCredits; // Port loses credits
                alert(`Success! Siphoned ${stolenCredits} credits!`);
                playSoundEffect('hack_success');
            } else {
                // Hack Failed
                alert("Failed! Access denied.");
                playSoundEffect('hack_fail');

                // --- Virus Infection Logic ---
                // Calculate the chance of getting a virus based on security difference
                // If port security is much higher, the chance increases significantly.
                const securityDifference = portSecurityLevel - playerComputerLevel;
                let virusInfectionChance = 0;

                if (securityDifference > 0) {
                    // Positive difference means port is more secure than player
                    virusInfectionChance = securityDifference * 0.1; // 10% increased chance per level difference
                } else {
                    // Negative difference or zero means player is equal or more secure
                    virusInfectionChance = 0.01; // Minimal chance even if player is superior
                }

                // Clamp the chance (e.g., max 50% chance of getting a virus on failure)
                virusInfectionChance = Math.min(0.5, virusInfectionChance);

                // Roll for virus infection
                if (Math.random() < virusInfectionChance) {
                    const randomVirusType = getRandomElement(virusTypes);
                    // Check if player already has this virus by name
                    const hasVirus = game.player.viruses.some(v => v.name === randomVirusType.name);

                    if (!hasVirus) {
                        // Add the virus with its starting duration
                        game.player.viruses.push({...randomVirusType, remainingDuration: randomVirusType.duration});
                        alert(`INTRUSION DETECTED! System infected with "${randomVirusType.name}" virus!`);
                        playSoundEffect('virus_infect');
                    } else {
                        // Virus failed to infect (already present)
                        alert("System defenses held against counter-intrusion.");
                    }
                } else {
                    // Failed hack, but no virus infection
                    alert("No counter-intrusion detected.");
                }
            }
            updateUI(); // Always update UI after a hack attempt
        }
    
        // Function to upgrade Port Security
         function upgradePortSecurity() {
             const sector = game.map[`${game.player.x},${game.player.y}`];
             if (!sector || sector.type !== 'port') {
                 alert("Upgrade security at ports only.");
                 playSoundEffect('error');
                 return;
             }
             const portData = sector.data;
             const targetLevel = parseInt(document.getElementById('upgrade-security-level').value) || portData.securityLevel + 1;
             const maxLevel = 10;
    
             if (targetLevel <= portData.securityLevel) {
                 alert("Enter a higher level.");
                 playSoundEffect('error');
                 return;
             }
             if (targetLevel > maxLevel) {
                 alert(`Max security level is ${maxLevel}.`);
                 playSoundEffect('error');
                 return;
             }
    
             // Cost increases with target level and current level
             // Example: Level 1->2 cost 10k, Level 9->10 cost increases significantly
             const cost = (targetLevel * 5000) + (portData.securityLevel * 5000) + 10000;
    
    
             if (game.player.credits < cost) {
                 alert(`Need ${cost} cr to upgrade to level ${targetLevel}.`);
                 playSoundEffect('error');
                 return;
             }
    
             if (confirm(`Upgrade port security to level ${targetLevel} for ${cost} cr?`)) {
                 game.player.credits -= cost;
                 portData.securityLevel = targetLevel;
                 alert(`Port security upgraded to level ${targetLevel}!`);
                 playSoundEffect('upgrade');
                 updateUI(); // Update UI to show new security level and cost
             }
         }
    
        // Function to upgrade Player Software (Computer Level)
         function upgradeSoftware() {
             const sector = game.map[`${game.player.x},${game.player.y}`];
              if (!sector || sector.type !== 'spacePort') {
                  alert("Upgrade software at space ports only.");
                  playSoundEffect('error');
                  return;
              }
             const currentLevel = game.player.ship.computerLevel || 1;
             const maxLevel = 10;
    
             if (currentLevel >= maxLevel) {
                 alert("Computer software is max level.");
                 playSoundEffect('error');
                 return;
             }
    
             // Cost increases with current level
             const cost = currentLevel * 10000; // Example cost: Level 1->2 costs 10k, Level 2->3 costs 20k
    
    
             if (game.player.credits < cost) {
                 alert(`Need ${cost} cr to upgrade to level ${currentLevel + 1}.`);
                 playSoundEffect('error');
                 return;
             }
    
             if (confirm(`Upgrade computer software to level ${currentLevel + 1} for ${cost} cr?`)) {
                 game.player.credits -= cost;
                 game.player.ship.computerLevel = currentLevel + 1;
                 alert(`Computer software upgraded to level ${game.player.ship.computerLevel}!`);
                 playSoundEffect('upgrade');
                 updateUI(); // Update UI to show new computer level
             }
         }
    
        // Function to remove Viruses
         function removeViruses() {
             const sector = game.map[`${game.player.x},${game.player.y}`];
             if (!sector || sector.type !== 'spacePort') {
                  alert("Remove viruses at space ports only.");
                  playSoundEffect('error');
                  return;
              }
             if (game.player.viruses.length === 0) {
                 alert("No viruses detected.");
                 playSoundEffect('error');
                 return;
             }
    
             const costPerVirus = 1000; // Example cost per virus
             const totalCost = game.player.viruses.length * costPerVirus;
    
             if (game.player.credits < totalCost) {
                 alert(`Need ${totalCost} cr for virus removal.`);
                 playSoundEffect('error');
                 return;
             }
    
             if (confirm(`Pay ${totalCost} cr to remove all viruses?`)) {
                 game.player.credits -= totalCost;
                 game.player.viruses = []; // Clear the viruses array
                 alert("Ship's systems cleaned. Viruses removed.");
                 playSoundEffect('virus_clean');
                 updateUI(); // Update UI to reflect no viruses
             }
         }
    
    
        function playLottery() { const sector = game.map[`${game.player.x},${game.player.y}`]; if (!sector || (sector.type !== 'port' && sector.type !== 'spacePort')) return; const ticketCost = 10; if (game.player.credits < ticketCost) { alert(`Need ${ticketCost}cr for ticket.`); playSoundEffect('error'); return; } const userNumbers = []; while(userNumbers.length < 6){ const r = getRandomInt(1, 49); if(userNumbers.indexOf(r) === -1) userNumbers.push(r); } userNumbers.sort((a, b) => a - b); if (!confirm(`Buy ticket for ${ticketCost}cr?\nYour numbers: ${userNumbers.join(', ')}`)) return; game.player.credits -= ticketCost; playSoundEffect('trade_sell'); const winningNumbers = []; while(winningNumbers.length < 6){ const r = getRandomInt(1, 49); if(winningNumbers.indexOf(r) === -1) winningNumbers.push(r); } winningNumbers.sort((a, b) => a - b); let matches = 0; userNumbers.forEach(num => { if (winningNumbers.includes(num)) matches++; }); let winnings = 0; if (matches === 3) winnings = 50; else if (matches === 4) winnings = 500; else if (matches === 5) winnings = 10000; else if (matches === 6) winnings = 1000000; let resultMessage = `Winning: ${winningNumbers.join(', ')}\nYours: ${userNumbers.join(', ')}\nMatches: ${matches}.`; if (winnings > 0) { resultMessage += `\nYou won ${winnings}cr!`; game.player.credits += winnings; playSoundEffect('trade_buy'); } else { resultMessage += `\nNo win.`; } alert(resultMessage); updateUI(); }
        function attemptPurchasePort() { const sector = game.map[`${game.player.x},${game.player.y}`]; if (!sector || sector.type !== 'port') { alert("Only trading ports considered."); playSoundEffect('error'); return; } const portData = sector.data;
            // Make purchase price and chance influenced by security level? Higher security = more expensive/less likely for sale?
            const basePrice = 500000;
            const priceModifier = (portData.securityLevel || 0) * 75000; // Price increases with security
            const price = portData.purchasePrice || (basePrice + priceModifier);
    
            const baseForSaleChance = 0.1; // 10% base chance
            const forSaleChanceModifier = (portData.securityLevel || 0) * -0.008; // Higher security slightly reduces for sale chance (0.8% per level)
            const forSale = portData.forSale !== undefined ? portData.forSale : (Math.random() < Math.max(0.01, baseForSaleChance + forSaleChanceModifier)); // Ensure min 1% chance
    
            if (!forSale) { alert("Operators not selling."); playSoundEffect('error'); return; } if (confirm(`Port for sale!\nPrice: ${price} cr.\nPurchase?`)) { if (game.player.credits >= price) { game.player.credits -= price; portData.owner = game.player.name; portData.forSale = false; // Port is no longer for sale after purchase
                // Optionally, you could give the player some benefits from owning a port, like a percentage of its trade profits over time.
                alert(`Congratulations! You own ${portData.name}!`); playSoundEffect('ship_bought'); updateUI(); } else { alert(`Cannot afford ${price} cr.`); playSoundEffect('error'); } } else { /* User cancelled purchase */ } updateUI(); }
        function payForTip() { const tipCost = 25; if (game.player.credits < tipCost) { alert(`Need ${tipCost}cr for tip.`); playSoundEffect('error'); return; } game.player.credits -= tipCost; playSoundEffect('trade_sell'); const tips = ["Heard tech pays well near Zarg.", "Pirates near Kepler.", "Derelict full of ore at 50,30?", "Food prices up near Terra?", "Don't buy alien artifacts.", "Vinari patrol near Duran space?", "Rare comet in outer rim?", "Starbase AC had repair discount?", "Saw ship asking about you...", "Weird signals near black holes." ]; alert(`Dockmaster whispers: "${getRandomElement(tips)}"`); updateUI(); }
    
        function hailNPC() {
            const sector = game.map[`${game.player.x},${game.player.y}`];
            if (!sector || !['npc_trader', 'vinari_ship', 'duran_ship'].includes(sector.type)) return;
            const npc = sector.data;
            if (npc.hostileLevel === 'High' && Math.random() < 0.5) {
                alert(`${npc.name} is hostile and opens fire!`);
                playSoundEffect('ship_destroyed');
                // Implement combat logic here
            } else {
                alert(`${npc.name} responds: "Greetings, trader. Want to barter?"`);
                // Open a trade dialog
                triggerAction('tradeWithNPC', npc);
            }
            updateUI();
        }
        function tradeWithNPC(npc) {
            // Example: NPCs have random inventory and prices
            const npcInventory = { ore: getRandomInt(0, 50), food: getRandomInt(0, 50), tech: getRandomInt(0, 20) };
            const prices = { ore: getRandomInt(50, 150), food: getRandomInt(20, 80), tech: getRandomInt(100, 400) };
            // Update UI to show trade options
            ui.interactionControls.innerHTML = `
                <p>Trading with ${npc.name}:</p>
                <div>Ore: ${npcInventory.ore} (Buy: ${prices.ore}cr, Sell: ${Math.floor(prices.ore * 0.8)}cr)</div>
                <div>Food: ${npcInventory.food} (Buy: ${prices.food}cr, Sell: ${Math.floor(prices.food * 0.8)}cr)</div>
                <div>Tech: ${npcInventory.tech} (Buy: ${prices.tech}cr, Sell: ${Math.floor(prices.tech * 0.8)}cr)</div>
                <button onclick="triggerAction('tradeNPC', 'buy', 'ore')">Buy Ore</button>
                <button onclick="triggerAction('tradeNPC', 'sell', 'ore')">Sell Ore</button>
                <!-- Add more buttons for food/tech -->
            `;
        }

        function updateEconomy() {
            game.ports.forEach(p => {
                commodities.forEach(c => {
                    // Random price fluctuation
                    p.prices[c] += getRandomInt(-5, 5);
                    p.prices[c] = Math.max(5, Math.min(p.prices[c], 500));
                });
            });
            // Add random events every 10 moves
            if (game.moveCount % 10 === 0) {
                const event = getRandomElement([
                    { msg: "Famine on Terra! Food prices spike.", effect: () => game.ports.forEach(p => p.prices.food += 20) },
                    { msg: "Tech boom in Cygnus sector!", effect: () => game.ports.forEach(p => p.prices.tech -= 10) }
                ]);
                alert(event.msg);
                event.effect();
            }
        }

        // Deep clone function to avoid circular references and ensure serializable data
        function deepClone(obj, seen = new WeakMap()) {
            if (obj === null || typeof obj !== 'object') return obj;
            if (seen.has(obj)) return null; // Avoid circular references
            seen.set(obj, true);

            if (Array.isArray(obj)) {
                return obj.map(item => deepClone(item, seen));
            }

            const cloned = {};
            for (const key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    cloned[key] = deepClone(obj[key], seen);
                }
            }
            return cloned;
        }

        // Save game state to localStorage
        function saveGame() {
            try {
                // Create a clean copy of the game state
                const gameState = deepClone(game);
                localStorage.setItem('cosmicTraderState', JSON.stringify(gameState));
                alert("Game saved successfully!");
                playSoundEffect('upgrade'); // Optional: Add sound for feedback
            } catch (e) {
                console.error("Save failed:", e);
                alert("Failed to save game. Check console for details.");
                playSoundEffect('error');
            }
        }

        // Load game state from localStorage
        function loadGame() {
            try {
                const saved = localStorage.getItem('cosmicTraderState');
                if (!saved) {
                    alert("No saved game found.");
                    playSoundEffect('error');
                    return;
                }
                if (confirm("Load saved game? This will overwrite current progress.")) {
                    const parsed = JSON.parse(saved);
                    // Deep replace game state
                    Object.keys(game).forEach(key => delete game[key]); // Clear current state
                    Object.assign(game, deepClone(parsed)); // Deep copy loaded state
                    updateUI();
                    alert("Game loaded successfully!");
                    playSoundEffect('upgrade');
                }
            } catch (e) {
                console.error("Load failed:", e);
                alert("Failed to load game. Check console for details.");
                playSoundEffect('error');
            }
        }
        
        // --- GAME CONTROL ---
        function restartGame() { if(!game.hasMoved||confirm("Restart? Progress lost.")){console.log("Restarting...");ui.bgmAudio.pause();initGame();}else{ui.mapSizeSelect.value=game.mapSize.toString();}}
    
        // --- INITIAL GAME START ---
        document.addEventListener('DOMContentLoaded', () => {
            // Add a single event listener to the document body and use event delegation
            document.body.addEventListener('click', (event) => {
                if (event.target.tagName === 'BUTTON') {
                    attemptFirstAudioPlay();
                    // You could add a specific UI click sound here if desired
                    // playSoundEffect('ui_click'); // Uncomment if you want a click sound on all buttons
                }
            });

            initGame();
        });

        document.addEventListener('keydown', (e) => {
            switch (e.key) {
                case 'ArrowUp': case 'w': triggerAction('move', 'up'); break;
                case 'ArrowDown': case 's': triggerAction('move', 'down'); break;
                case 'ArrowLeft': case 'a': triggerAction('move', 'left'); break;
                case 'ArrowRight': case 'd': triggerAction('move', 'right'); break;
                case 'm': if (!ui.deployMineButton.disabled) triggerAction('deployMine'); break;
            }
        });
    
    </script>
</body>
</html>
